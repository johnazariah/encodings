name: Prepare Release

# Trigger from GitHub UI or CLI:
#   gh workflow run release-dispatch.yml -f bump=auto
#   gh workflow run release-dispatch.yml -f bump=minor

on:
  workflow_dispatch:
    inputs:
      bump:
        description: 'Version bump type'
        required: true
        default: 'auto'
        type: choice
        options:
          - auto
          - patch
          - minor
          - major

permissions:
  contents: write

jobs:
  prepare-release:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.new_version }}
      tag: ${{ steps.version.outputs.tag }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for commit analysis
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Analyze commits and determine version
        id: version
        run: |
          set -euo pipefail

          # Get last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          FIRST_RELEASE=false
          if [[ -z "$LAST_TAG" ]]; then
            echo "::notice::No previous release found. This will be the first release."
            LAST_TAG="$(git rev-list --max-parents=0 HEAD)"
            LAST_VERSION="0.0.0"
            FIRST_RELEASE=true
          else
            LAST_VERSION="${LAST_TAG#v}"
            echo "::notice::Last release: $LAST_TAG"
          fi

          # Current version from .fsproj
          FSPROJ="src/Encodings/Encodings.fsproj"
          CURRENT_VERSION=$(grep -oP '(?<=<Version>)[^<]+' "$FSPROJ")
          echo "Current .fsproj version: $CURRENT_VERSION"

          # Analyze commits
          if [[ "$LAST_TAG" == "$(git rev-list --max-parents=0 HEAD)" ]]; then
            COMMITS=$(git log --oneline)
          else
            COMMITS=$(git log "${LAST_TAG}..HEAD" --oneline)
          fi

          if [[ -z "$COMMITS" ]]; then
            echo "::error::No commits since last release. Nothing to release."
            exit 1
          fi

          COMMIT_COUNT=$(echo "$COMMITS" | wc -l)
          echo "Found $COMMIT_COUNT commits since last release"

          # Categorize commits
          BREAKING=$(echo "$COMMITS" | grep -ciE '(BREAKING|!:)' || true)
          FEATURES=$(echo "$COMMITS" | grep -ciE '^[a-f0-9]+ feat' || true)
          FIXES=$(echo "$COMMITS" | grep -ciE '^[a-f0-9]+ fix' || true)

          echo "Breaking: $BREAKING, Features: $FEATURES, Fixes: $FIXES"

          # Parse version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

          # Determine bump
          BUMP="${{ inputs.bump }}"
          if [[ "$FIRST_RELEASE" == "true" ]]; then
            NEW_VERSION="$CURRENT_VERSION"
            BUMP_LABEL="initial"
          elif [[ "$BUMP" == "auto" ]]; then
            if [[ $BREAKING -gt 0 ]]; then
              NEW_VERSION="$((MAJOR + 1)).0.0"
              BUMP_LABEL="major"
            elif [[ $FEATURES -gt 0 ]]; then
              NEW_VERSION="$MAJOR.$((MINOR + 1)).0"
              BUMP_LABEL="minor"
            else
              NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
              BUMP_LABEL="patch"
            fi
          else
            case "$BUMP" in
              major) NEW_VERSION="$((MAJOR + 1)).0.0" ;;
              minor) NEW_VERSION="$MAJOR.$((MINOR + 1)).0" ;;
              patch) NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))" ;;
            esac
            BUMP_LABEL="$BUMP"
          fi

          echo "::notice::Releasing v$NEW_VERSION ($BUMP_LABEL bump)"
          echo "new_version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
          echo "tag=v$NEW_VERSION" >> "$GITHUB_OUTPUT"
          echo "current_version=$CURRENT_VERSION" >> "$GITHUB_OUTPUT"
          echo "first_release=$FIRST_RELEASE" >> "$GITHUB_OUTPUT"

          # Save commit data for changelog generation
          echo "$COMMITS" > /tmp/commits.txt
          echo "commits_file=/tmp/commits.txt" >> "$GITHUB_OUTPUT"

      - name: Update .fsproj version
        run: |
          FSPROJ="src/Encodings/Encodings.fsproj"
          CURRENT="${{ steps.version.outputs.current_version }}"
          NEW="${{ steps.version.outputs.new_version }}"
          sed -i "s|<Version>$CURRENT</Version>|<Version>$NEW</Version>|" "$FSPROJ"
          echo "Updated $FSPROJ: $CURRENT â†’ $NEW"

      - name: Generate CHANGELOG entry
        run: |
          set -euo pipefail
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          DATE=$(date +%Y-%m-%d)

          # Get last tag for commit range
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [[ -z "$LAST_TAG" ]]; then
            LAST_TAG="$(git rev-list --max-parents=0 HEAD)"
          fi

          # Get commits
          if [[ "$LAST_TAG" == "$(git rev-list --max-parents=0 HEAD)" ]]; then
            COMMITS=$(git log --oneline)
          else
            COMMITS=$(git log "${LAST_TAG}..HEAD" --oneline)
          fi

          # Categorize
          BREAKING=$(echo "$COMMITS" | grep -iE '(BREAKING|!:)' || true)
          FEATURES=$(echo "$COMMITS" | grep -iE '^[a-f0-9]+ feat' || true)
          FIXES=$(echo "$COMMITS" | grep -iE '^[a-f0-9]+ fix' || true)
          DOCS=$(echo "$COMMITS" | grep -iE '^[a-f0-9]+ docs' || true)
          CHORES=$(echo "$COMMITS" | grep -iE '^[a-f0-9]+ (chore|refactor|ci|test)' || true)

          # Build entry
          ENTRY="## [$NEW_VERSION] - $DATE"$'\n\n'

          if [[ -n "$BREAKING" ]]; then
            ENTRY+="### âš  BREAKING CHANGES"$'\n\n'
            while IFS= read -r c; do ENTRY+="- ${c#* }"$'\n'; done <<< "$BREAKING"
            ENTRY+=$'\n'
          fi
          if [[ -n "$FEATURES" ]]; then
            ENTRY+="### âœ¨ Features"$'\n\n'
            while IFS= read -r c; do ENTRY+="- ${c#* }"$'\n'; done <<< "$FEATURES"
            ENTRY+=$'\n'
          fi
          if [[ -n "$FIXES" ]]; then
            ENTRY+="### ðŸ› Bug Fixes"$'\n\n'
            while IFS= read -r c; do ENTRY+="- ${c#* }"$'\n'; done <<< "$FIXES"
            ENTRY+=$'\n'
          fi
          if [[ -n "$DOCS" ]]; then
            ENTRY+="### ðŸ“š Documentation"$'\n\n'
            while IFS= read -r c; do ENTRY+="- ${c#* }"$'\n'; done <<< "$DOCS"
            ENTRY+=$'\n'
          fi
          if [[ -n "$CHORES" ]]; then
            ENTRY+="### ðŸ”§ Maintenance"$'\n\n'
            while IFS= read -r c; do ENTRY+="- ${c#* }"$'\n'; done <<< "$CHORES"
            ENTRY+=$'\n'
          fi

          # Write changelog
          CHANGELOG="CHANGELOG.md"
          if [[ -f "$CHANGELOG" ]]; then
            HEADER=$(head -n 5 "$CHANGELOG")
            BODY=$(tail -n +6 "$CHANGELOG")
            {
              echo "$HEADER"
              echo ""
              echo "$ENTRY"
              echo "$BODY"
            } > "$CHANGELOG"
          else
            cat > "$CHANGELOG" << EOF
          # Changelog

          All notable changes to FockMap will be documented in this file.

          $ENTRY
          EOF
          fi

          echo "Generated CHANGELOG.md entry for v$NEW_VERSION"

      - name: Update CITATION.cff
        run: |
          if [[ -f CITATION.cff ]]; then
            NEW_VERSION="${{ steps.version.outputs.new_version }}"
            DATE=$(date +%Y-%m-%d)
            sed -i "s|^version: .*|version: $NEW_VERSION|" CITATION.cff
            sed -i "s|^date-released: .*|date-released: $DATE|" CITATION.cff
            echo "Updated CITATION.cff to v$NEW_VERSION"
          fi

      - name: Commit release changes
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          git add -A
          git commit -m "chore(release): v$NEW_VERSION

          - Update version to $NEW_VERSION
          - Generate CHANGELOG entry
          - Update CITATION.cff

          [automated release]"

      - name: Create and push tag
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          git tag -a "$TAG" -m "Release $TAG"
          git push origin HEAD
          git push origin "$TAG"
          echo "::notice::Pushed tag $TAG â€” release workflow will now run"

      - name: Summary
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          VERSION="${{ steps.version.outputs.new_version }}"
          cat >> "$GITHUB_STEP_SUMMARY" << EOF
          ## ðŸš€ Release $TAG prepared

          | | |
          |---|---|
          | **Version** | $VERSION |
          | **Tag** | $TAG |
          | **Date** | $(date +%Y-%m-%d) |

          ### Next steps
          The [$TAG push triggers the Release workflow](../actions/workflows/release.yml), which will:
          1. Run multi-platform tests (Linux, Windows, macOS)
          2. Pack and publish to NuGet
          3. Create a GitHub Release

          **Monitor:** \`gh run watch --workflow=release.yml\`
          EOF
