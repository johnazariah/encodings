% drafts/02-background.tex â€” Background
%
% Target length: ~3 pages (two-column PRA)
% Subsections: 2.1 Fermionic algebra, 2.2 Pauli algebra,
%              2.3 Known encodings, 2.4 Majorana framework

%%====================================================================
\subsection{The fermionic algebra}
\label{sec:bg-fermion}

We consider $n$ fermionic modes with creation operators $\ad{j}$ and
annihilation operators $\an{j}$, $j = 0, \ldots, n{-}1$.  These satisfy
the \emph{canonical anticommutation relations} (CAR):
%
\begin{align}
  \acomm{\an{i}}{\ad{j}} &= \delta_{ij}, \label{eq:car1} \\
  \acomm{\an{i}}{\an{j}} &= \acomm{\ad{i}}{\ad{j}} = 0.
    \label{eq:car2}
\end{align}
%
The Fock space $\mathcal{F}$ is a $2^n$-dimensional Hilbert space
spanned by occupation-number states $\ket{f_{n-1} \cdots f_1 f_0}$,
$f_j \in \{0,1\}$.

It is convenient to introduce the \emph{Majorana operators}
\begin{equation}
  c_j = \ad{j} + \an{j}, \qquad
  d_j = i(\ad{j} - \an{j}),
  \label{eq:majorana}
\end{equation}
which satisfy $\acomm{c_j}{c_k} = 2\delta_{jk}$,
$\acomm{d_j}{d_k} = 2\delta_{jk}$, and $\acomm{c_j}{d_k} = 0$.
Any encoding that correctly maps the $2n$ Majorana operators to
Pauli strings automatically preserves the full CAR.

%%====================================================================
\subsection{The Pauli algebra}
\label{sec:bg-pauli}

A system of $n$ qubits is described by the Pauli group $\mathcal{P}_n$
generated by $n$-fold tensor products of $\{I, X, Y, Z\}$.  The key
structural difference from fermions is that Pauli operators on distinct
qubits \emph{commute}:
%
\begin{equation}
  \sigma_i^{(\alpha)} \sigma_j^{(\beta)}
  = \sigma_j^{(\beta)} \sigma_i^{(\alpha)}
  \quad (i \neq j).
  \label{eq:pauli-commute}
\end{equation}
%
A fermion-to-qubit encoding must therefore embed the anticommutative
fermionic algebra into the commutative-across-sites Pauli algebra by
constructing Pauli \emph{strings} whose non-trivial support on multiple
qubits enforces the required sign changes.

\begin{definition}[Pauli weight]
\label{def:pauli-weight}
The \emph{Pauli weight} of a Pauli string
$\sigma = \sigma_0 \otimes \cdots \otimes \sigma_{n-1}$ is
$\pauliw{\sigma} = |\{i : \sigma_i \neq I\}|$.
\end{definition}

Pauli weight directly determines gate count, measurement complexity, and
noise sensitivity on real hardware.  It is therefore the primary metric
by which encodings are compared \cite{havlicek2017,tranter2015}.

%%====================================================================
\subsection{Review of known encodings}
\label{sec:bg-encodings}

We briefly recall the three most widely used encodings.

\paragraph{Jordan--Wigner (1928).}
The oldest and simplest encoding \cite{jordan1928} maps
$\ad{j} \mapsto \frac{1}{2}(X_j - iY_j) \prod_{k<j} Z_k$.
The trailing $Z$-string enforces anticommutation but grows linearly:
$\pauliw{\ad{j}} = j + 1 = O(n)$.

\paragraph{Bravyi--Kitaev (2002).}
By organising modes into a Fenwick tree \cite{fenwick1994},
the BK encoding \cite{bravyi2002,seeley2012} achieves
$\pauliw{\ad{j}} = O(\log_2 n)$.

\paragraph{Parity encoding.}
Qubit $j$ stores the cumulative parity $\bigoplus_{k \le j} f_k$.
Creation operators again have $O(n)$ weight, but the total-parity
operator collapses to a single $Z$, enabling direct qubit tapering
\cite{bravyi2017tapering}.

All three, together with balanced binary and ternary tree variants
\cite{jiang2020,miller2023bonsai}, will be recovered as special cases
of the tree--encoding correspondence in~\cref{sec:tree-encoding}.

%%====================================================================
\subsection{The Majorana framework}
\label{sec:bg-majorana}

An encoding is fully specified by a map
$\{c_j, d_j\}_{j=0}^{n-1} \to \mathcal{P}_n$ such that the Majorana
anticommutation relations are preserved.  This reduces the design
problem to finding $2n$ mutually anticommuting Pauli strings in
$\mathcal{P}_n$.

\begin{lemma}
For any $n \ge 1$, there exist $2n$ mutually anticommuting
$n$-qubit Pauli strings.
\end{lemma}
\begin{proof}
The Jordan--Wigner construction provides an explicit family.
\end{proof}

The two constructions we present in \cref{sec:tree-encoding} are both
instances of this framework, differing in how the tree geometry is used
to \emph{choose} the $2n$ strings.
