% FockMap — JOSS Paper
% Compiled with: latexmk -pdf paper.tex
\documentclass[10pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{natbib}
\usepackage{authblk}
\usepackage{geometry}
\usepackage{fancyvrb}
\usepackage{listings}

\geometry{margin=1in}
\bibliographystyle{unsrtnat}

% Code listing style for F#
\lstdefinelanguage{FSharp}{
  morekeywords={let,in,if,then,else,match,with,type,of,open,module,fun,rec,mutable,new,true,false,set},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{(*}{*)},
  morestring=[b]",
}
\lstset{
  language=FSharp,
  basicstyle=\ttfamily\small,
  keywordstyle=\bfseries\color{blue!70!black},
  commentstyle=\itshape\color{green!50!black},
  stringstyle=\color{red!60!black},
  frame=single,
  breaklines=true,
  columns=fullflexible,
}

\hypersetup{
  colorlinks=true,
  linkcolor=blue!70!black,
  citecolor=green!50!black,
  urlcolor=blue!60!black,
}

%%--------------------------------------------------------------------

\title{FockMap: A Composable Functional Framework for\\
  Symbolic Fock-Space Operator Algebra and Fermion-to-Qubit Encodings in F\#}

\author[1]{John Azariah\thanks{ORCID: \href{https://orcid.org/0009-0007-9870-1970}{0009-0007-9870-1970}}}
\affil[1]{University of Technology Sydney}

\date{February 2026}

%%--------------------------------------------------------------------
\begin{document}
\maketitle

%%--------------------------------------------------------------------
\section*{Summary}

Simulating fermionic systems on quantum hardware requires a mapping
from fermionic ladder operators to qubit Pauli operators.  This
fermion-to-qubit encoding step strongly influences Pauli weight,
measurement cost, and circuit depth.  Although widely used encodings
(Jordan--Wigner, Bravyi--Kitaev, Parity, and tree-based variants) share
substantial algebraic structure, they are often implemented in existing
software as isolated transformations rather than as instances of a
common formal interface.

\texttt{FockMap} is an open-source F\# library that formalizes this
shared structure through two composable abstractions: \emph{index-set
schemes}, defined by three set-valued functions (\texttt{Update},
\texttt{Parity}, \texttt{Occupation}), and \emph{path-based tree
encodings}, in which any rooted labelled tree induces a valid
encoding.  The index-set abstraction expresses Jordan--Wigner,
Bravyi--Kitaev, and Parity in 3--5 lines each, while the path-based
abstraction supports arbitrary tree topologies, including balanced
binary and balanced ternary trees with optimal $O(\log n)$ asymptotic
Pauli weight.

The operator-processing pipeline is implemented symbolically: Pauli
strings are multiplied exactly with algebraic phase tracking, without
constructing operator matrices and without introducing floating-point
error in intermediate steps.  Numerical coefficients are introduced only
at Hamiltonian assembly.  This design supports transparent correctness
checks and avoids numerical artefacts common in matrix-first workflows.

In addition to the fermionic canonical anti-commutation workflow,
\texttt{FockMap} includes a bosonic canonical commutation algebra
for symbolic normal ordering of ladder-operator expressions, as well
as three bosonic-to-qubit truncation encodings (Unary, Standard Binary,
and Gray Code) that map $d$-level bosonic modes to qubit Pauli strings
\citep{sawaya2020}.  This extends the same typed expression pipeline
to both fermionic and bosonic sectors, supporting mixed-statistics
model assembly in a single representation.

The library is implemented with algebraic data types and pure functions,
includes a persistent Fenwick tree ADT, and is validated by an extensive
xUnit + FsCheck test suite (497 passing tests), including both
property-based algebraic checks and targeted edge-case regressions.
A complete H$_2$/STO-3G example is provided and reproduced across all
five built-in encodings.

A companion walkthrough (\emph{Library Cookbook}) is available both as
hosted documentation on the repository website and as a standalone
typeset document~\cite{cookbook2026}, providing 13 progressive chapters
that cover every public type, function, and workflow in the library.

%%--------------------------------------------------------------------
\section*{Statement of Need}

Quantum simulation of molecular electronic structure is widely regarded
as one of the most promising near-term applications of quantum computing
\citep{feynman1982,aspuruguzik2005}.  Between the molecular Hamiltonian
in second quantization and the measurements performed on quantum
hardware lies a critical middleware step: the fermion-to-qubit encoding.
The choice of encoding determines the Pauli weight of each operator (and
hence circuit depth), the number of measurement terms, and ultimately
whether a simulation is feasible on a given device.

Current tools for this step, OpenFermion \citep{mcclean2020}, Qiskit
Nature \citep{qiskit2023}, and PennyLane \citep{bergholm2022},
implement each encoding as a monolithic function mapping
\texttt{FermionOperator} $\to$ \texttt{QubitOperator}.  Adding a new
encoding requires writing hundreds of lines of bespoke code.  The
mathematical structure shared across encodings (Majorana decomposition,
parity tracking, update sets) is duplicated rather than abstracted.
There is no mechanism for users to define, compose, or compare custom
encodings programmatically.

\texttt{FockMap} addresses this gap by representing an encoding as a
\emph{value} (a record of three functions) rather than as an opaque
class hierarchy.  This design enables:

\begin{itemize}
  \item \textbf{Exploration:} researchers can define and test novel
    encodings in 3--5 lines of code.
  \item \textbf{Comparison:} all encodings share the same verification
    pipeline (anti-commutation tests, eigenspectrum comparison).
  \item \textbf{Pedagogy:} the implementation remains close to the
    formal definitions in the literature; an \texttt{EncodingScheme}
    directly encodes the mathematical specification.
\end{itemize}

Many contemporary models also require bosonic modes (for example,
vibrational and photonic degrees of freedom), where canonical
commutation relations govern symbolic rewriting.  A practical software
stack therefore needs both fermionic and bosonic ladder-operator
normal-ordering support, together with bosonic-to-qubit truncation
encodings, before downstream circuit synthesis can proceed.  Existing
libraries provide neither bosonic-to-qubit encodings nor a unified
framework for mixed fermion--boson workflows.

The library serves quantum computing researchers exploring
encoding-aware circuit synthesis, students learning the algebraic
structure of encodings, and developers building simulation pipelines who
need a correct and composable symbolic operator layer.

%%--------------------------------------------------------------------
\section*{Functionality}

\subsection*{Encoding Schemes (Index-Set Framework)}

The \texttt{EncodingScheme} record type captures the three index-set
functions that define a fermion-to-qubit encoding.  Three concrete
schemes are provided: \texttt{jordanWignerScheme},
\texttt{bravyiKitaevScheme}, and \texttt{parityScheme}.  User-defined
schemes are first-class values of the same type:

\begin{lstlisting}
let myScheme : EncodingScheme =
    { Update     = fun j n -> set [ j + 1 .. n - 1 ]
      Parity     = fun j   -> if j > 0 then Set.singleton (j - 1)
                               else Set.empty
      Occupation  = fun j   -> if j > 0 then set [j-1; j]
                               else Set.singleton j }
\end{lstlisting}

The framework automatically constructs Majorana operators $c_j$ and
$d_j$ from these three functions, then derives ladder operators
$a^\dagger_j$ and $a_j$ by linear combination.

\subsection*{Tree Encodings (Path-Based Framework)}

Any rooted labelled tree defines a fermion-to-qubit encoding.  The
library provides \texttt{balancedBinaryTree} and
\texttt{balancedTernaryTree} constructors; users can build arbitrary
trees from \texttt{TreeNode} values.  The path-based encoding function
traverses the tree to construct Majorana operators without requiring the
index-set monotonicity constraint, making it strictly more general than
the index-set framework.

\subsection*{Symbolic Algebra Engine}

A distinguishing feature of \texttt{FockMap} is that operator
multiplication is entirely symbolic.  The \texttt{PauliRegister} type
represents a Pauli string (e.g.\ $XZIY$) together with an exact
\texttt{Phase} drawn from $\{+1, -1, +i, -i\}$.  Multiplying two Pauli
registers applies the single-qubit multiplication table
($X \cdot Y = iZ$, etc.)  position-wise and accumulates the phase
algebraically; no $2^n \times 2^n$ matrices are ever constructed.
The resulting \texttt{PauliRegisterSequence} (a weighted sum of Pauli
strings) is the symbolic representation of an encoded operator.

This design means that encoding a ladder operator on 100 modes produces
a compact list of Pauli strings, not a $2^{100} \times 2^{100}$ sparse
matrix.  Correctness can be verified symbolically: the anti-commutation
tests in the verification suite check $\{a_i, a^\dagger_j\} =
\delta_{ij}$ by Pauli string cancellation, not by matrix eigenvalue
comparison.

The library also includes a persistent \texttt{FenwickTree<'a>}
(parameterised over any monoid) and a \texttt{Hamiltonian} module for
constructing molecular Hamiltonians from one-body and two-body integrals.

Normal ordering is parameterized by a combining-algebra interface.
\texttt{FermionicAlgebra} implements canonical anti-commutation
relations, while \texttt{BosonicAlgebra} implements canonical
commutation relations.  This allows both statistics to share the same
typed expression representation, while preserving distinct rewrite rules
($a_i a_i^\dagger = 1 - a_i^\dagger a_i$ versus
$b_i b_i^\dagger = 1 + b_i^\dagger b_i$).

\subsection*{Bosonic-to-Qubit Encodings}

For bosonic modes truncated to $d$ occupation levels, the library
provides three encoding strategies that map bosonic ladder operators
$b^\dagger$ and $b$ to qubit Pauli strings:

\begin{itemize}
  \item \textbf{Unary (one-hot):} $d$ qubits per mode, maximum Pauli
    weight~2.  Each transition $|n\rangle \to |n{+}1\rangle$ is
    decomposed algebraically as $\sigma^+_{n+1}\sigma^-_n$.
  \item \textbf{Standard binary:} $\lceil\log_2 d\rceil$ qubits per
    mode.  The $d \times d$ operator matrix is embedded in a
    $2^q \times 2^q$ space and decomposed via
    $O = \sum_P \tfrac{1}{2^q}\text{Tr}(PO)\,P$.
  \item \textbf{Gray code:} $\lceil\log_2 d\rceil$ qubits per mode.
    Consecutive Fock states differ in exactly one qubit, reducing the
    average Pauli weight of transition operators.
\end{itemize}

All three encodings produce \texttt{PauliRegisterSequence} values,
making them interchangeable with the fermionic encoding output and
enabling mixed fermion--boson Hamiltonian assembly in a single pipeline.

\subsection*{Verification Suite}

The verification strategy combines unit tests, property-based tests, and
cross-encoding consistency checks.  At submission time, 497 tests pass
for the software package.

Tests cover six categories:
\begin{itemize}
  \item \textbf{Anti-commutation:}
    $\{a_i, a^\dagger_j\} = \delta_{ij}$ verified symbolically for all
    mode pairs.
  \item \textbf{Commutation:}
    $[b_i, b^\dagger_j] = \delta_{ij}$ verified symbolically for bosonic
    rewrite cases, including same-index identity generation and
    different-index swap behavior.
  \item \textbf{Number conservation:}
    $a^\dagger_j a_j$ produces diagonal Pauli operators.
  \item \textbf{Cross-encoding agreement:} all five fermionic encodings
    produce isospectral Hamiltonians for H$_2$ (eigenvalue agreement to
    $5 \times 10^{-16}$).
  \item \textbf{Bosonic encoding correctness (70 tests):}
    matrix construction, Pauli decomposition infrastructure,
    Pauli-weight bounds ($\leq 2$ for unary, $\leq \lceil\log_2 d\rceil$
    for binary/Gray), multi-mode embedding, number-operator roundtrip
    ($b^\dagger b \to \tfrac{1}{2}(I - Z)$ at $d = 2$), and
    cross-encoding consistency between binary and Gray code.
  \item \textbf{Parser and ordering robustness:} malformed input handling,
    normal/index-order canonicalization, and swap-tracking edge branches for
    deterministic symbolic normalization.
\end{itemize}

%%--------------------------------------------------------------------
\section*{Design Principles}

\paragraph{Encodings as data.}
An \texttt{EncodingScheme} is a value, not a class hierarchy.
Jordan--Wigner, Bravyi--Kitaev, and Parity are different values of the
same type.  This enables algebraic reasoning: one can ask whether two
schemes agree on a given mode without running a full encoding.

\paragraph{Two complementary frameworks.}
The index-set framework (\texttt{MajoranaEncoding.fs}) is fast and
algebraically transparent but requires a monotonicity condition on
ancestor indices.  The path-based framework (\texttt{TreeEncoding.fs})
works for \emph{any} tree topology.  Both produce the same output type
(\texttt{PauliRegisterSequence}), so downstream code is
encoding-agnostic.

\paragraph{Symbolic over numerical.}
Existing libraries represent operators as sparse matrices or coefficient
dictionaries indexed by opaque integer keys.  \texttt{FockMap}
represents them as typed Pauli strings with exact algebraic phases.
This makes the intermediate representation human-readable, composable,
and free of floating-point error accumulation.  Numerical coefficients
enter only at the Hamiltonian assembly stage, where they multiply
symbolic Pauli terms.

\paragraph{Pure functions, no mutation.}
All data structures are immutable: persistent Fenwick trees, recursive
tree ADTs, and Pauli register sequences.  The library has zero mutation
and no side effects in its core modules.

\paragraph{Discovered constraints.}
Implementation and testing revealed that the index-set framework's
monotonicity requirement (ancestor indices must exceed descendant
indices) is satisfied only by star-shaped trees, a structural
constraint not previously documented in the literature.  This discovery
motivated the path-based framework as a universal alternative and is
explored further in a companion paper.

%%--------------------------------------------------------------------
\section*{Documentation}

The repository includes four tiers of documentation:

\begin{enumerate}
  \item \textbf{Library Cookbook} — a 13-chapter progressive tutorial
    covering every public type and function, from Pauli operators
    through custom encodings to mixed bosonic--fermionic Hamiltonians.
    Available as hosted Markdown on the documentation site and as a
    companion preprint~\cite{cookbook2026}.
  \item \textbf{From Molecules to Qubits} — a pedagogical walkthrough
    of the complete H$_2$ pipeline, available as both web documentation
    and a separate preprint~\cite{tutorial2026}.
  \item \textbf{Theory pages} — seven background articles on second
    quantization, Pauli algebra, and encoding theory.
  \item \textbf{Interactive labs} — six runnable F\# scripts with
    guided exercises.
\end{enumerate}

%%--------------------------------------------------------------------
\section*{Comparison with Related Software}

\begin{table}[h]
\centering
\small
\begin{tabular}{@{}lccccc@{}}
\toprule
\textbf{Feature} & \textbf{OpenFermion} & \textbf{Qiskit Nature}
  & \textbf{PennyLane} & \textbf{FockMap} \\
\midrule
JW / BK / Parity
  & \checkmark/\checkmark/\checkmark
  & \checkmark/\checkmark/\checkmark
  & \checkmark/\checkmark/---
  & \checkmark/\checkmark/\checkmark \\
Tree encodings & Steiner ext. & --- & --- & Binary, Ternary \\
Bosonic CCR algebra & --- & --- & \checkmark & \checkmark \\
Bosonic-to-qubit encodings & --- & --- & --- & \checkmark \\
Mixed fermion--boson ordering & --- & --- & --- & \checkmark \\
User-defined encodings & --- & --- & --- & \checkmark \\
User-defined trees & --- & --- & --- & \checkmark \\
Generic encoding abstraction & --- & --- & --- & \checkmark \\
Symbolic Pauli algebra & --- & Partial & \checkmark & \checkmark \\
Typed / functional & --- & --- & --- & \checkmark \\
Persistent Fenwick tree & --- & --- & --- & \checkmark \\
\bottomrule
\end{tabular}
\caption{Feature comparison with existing fermion-to-qubit and bosonic
encoding libraries.  FockMap is the only library providing both fermionic
and bosonic-to-qubit encodings within a single symbolic algebra framework.}
\label{tab:comparison}
\end{table}

OpenFermion \citep{mcclean2020} is the most comprehensive existing tool,
offering extensive support for operator manipulation and circuit
synthesis.  Qiskit Nature \citep{qiskit2023} integrates tightly with IBM
quantum hardware.  PennyLane \citep{bergholm2022} excels at
differentiable quantum computing.  \texttt{FockMap} does not compete on
scope; it provides the \emph{framework} abstraction that these libraries
lack, enabling systematic exploration and comparison of encodings.

%%--------------------------------------------------------------------
\section*{Acknowledgements}

This work is dedicated to Dr.\ Guang Hao Low, whose early encouragement
to study Bravyi--Kitaev encodings motivated the development of this
symbolic algebra framework.  The author also acknowledges the F\#
Software Foundation and the .NET open-source community for the language
and runtime ecosystem supporting this work.

%%--------------------------------------------------------------------
\bibliography{paper}
% Note: paper.bib must include cookbook2026 and tutorial2026 entries

\end{document}
