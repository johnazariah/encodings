# FockMap Type System Guide

FockMap's type system uses a three-level algebraic hierarchy to represent quantum operator expressions. This guide explains how the `C<'T>`, `P<'T>`, `S<'T>` types work, how algebra semantics (CAR/CCR) are injected, and how to structure mixed bosonic/fermionic models safely.

## The Three-Level Algebra

Quantum Hamiltonians in second quantization follow a natural hierarchical structure:

```
H = Σᵢ cᵢ (Ô₁ⁱ Ô₂ⁱ ... Ôₖⁱ)
```

FockMap models this with three generic types:

### C&lt;'T&gt; — Coefficient-Operator Pair

The simplest building block: a complex coefficient times a single operator unit.

```fsharp
type C<'unit when 'unit : equality> =
    { Coeff : Complex
      Item  : 'unit }
```

Examples:
- `1.0 × a†₂` — creation operator on mode 2
- `0.5 × X₀` — half times Pauli-X on qubit 0
- `i × Z₁` — imaginary unit times Pauli-Z on qubit 1

The tensor product operator `(*)` combines two `C` values into a product `P`:

```fsharp
let term1 = C.Apply(Raise)  // a†
let term2 = C.Apply(Lower)  // a
let product = term1 * term2 // a†a as a P<'T>
```

### P&lt;'T&gt; — Product of Operators

An ordered sequence of coefficient-operator pairs with an overall coefficient:

```fsharp
type P<'unit when 'unit : equality> =
    { Coeff : Complex
      Units : C<'unit>[] }
```

The ordering of `Units` is significant for non-commuting operators. Examples:
- `a†₁ a₂` — two-operator product (hopping term)
- `0.5 × a†₁ a†₂ a₃ a₄` — four-operator product (two-electron integral)
- `X₀ Z₁ X₂` — three-qubit Pauli string

Products support tensor multiplication:

```fsharp
let p1 = P.Apply([| Raise; Lower |])  // a†a
let p2 = P.Apply([| Raise; Lower |])  // a†a
let p12 = p1 * p2                      // a†a a†a as a single P
```

### S&lt;'T&gt; — Sum of Products

The full Hamiltonian representation: a sum of product terms.

```fsharp
type S<'unit when 'unit : equality> =
    { Coeff : Complex
      Terms : Map<string, P<'unit>> }
```

The map keying by string representation enables automatic combination of like terms:

```fsharp
let h1 = S.Apply(P.Apply(Complex(0.5, 0.), [| term1 |]))
let h2 = S.Apply(P.Apply(Complex(0.3, 0.), [| term1 |]))
let h = h1 + h2  // Combines to 0.8 × term1
```

## Why the Type Parameter Matters

The generic type parameter `'unit` allows the **same algebraic structure** to work with indexed ladder operators and Pauli operators:

| Type Parameter | Algebra Represents |
|----------------|-------------------|
| `LadderOperatorUnit` | Indexed ladder operators before algebra-specific normalization |
| `PauliRegister` | Qubit Pauli strings |

This design provides several benefits:

### Unified Operator Manipulation

Both fermionic and Pauli expressions support the same operations:

```fsharp
// Ladder-operator Hamiltonian
let ferm : S<IxOp<uint32, LadderOperatorUnit>> = ...
let ferm2 = ferm * ferm  // Works

// Pauli Hamiltonian
let pauli : S<PauliRegister> = ...
let pauli2 = pauli * pauli  // Also works, same interface
```

### Type-Safe Encoding Boundary

The type system clearly demarcates where encoding happens. You cannot accidentally mix ladder-operator terms with Pauli terms—they have different type parameters:

```fsharp
// This won't compile: type mismatch
let mixed = fermionicTerm * pauliTerm  // Error!
```

### Reusable Algebraic Operations

Functions like `Reduce`, `ScaleCoefficient`, and `NormalizeTermCoefficient` work identically regardless of whether you're working with fermions or qubits.

## Normal Ordering as Algebraic Rewriting

Normal ordering transforms a product so that all creation operators (a†) appear before all annihilation operators (a). FockMap supports this for both fermionic and bosonic algebras.

### The Challenge

Fermionic operators anti-commute. Swapping two adjacent operators:
- Introduces a factor of −1
- May generate additional terms (when swapping `aᵢ` past `a†ᵢ` with the same index)

The canonical anti-commutation relations (CAR):

```
{a†ᵢ, aⱼ} = a†ᵢ aⱼ + aⱼ a†ᵢ = δᵢⱼ
{aᵢ, aⱼ} = 0
{a†ᵢ, a†ⱼ} = 0
```

### Implementation via ICombiningAlgebra

FockMap abstracts the term-generation rules through an interface:

```fsharp
type ICombiningAlgebra<'op when 'op : equality> =
    interface
        abstract Combine : P<IxOp<uint32, 'op>> -> C<IxOp<uint32, 'op>> -> P<IxOp<uint32, 'op>>[]
    end
```

The `Combine` method takes a partial product and the next operator, returning all terms that result from appending—including any terms generated by commutation relations.

### FermionicAlgebra (CAR)

The fermionic implementation handles the CAR:

```fsharp
type FermionicAlgebra () =
    interface ICombiningAlgebra<LadderOperatorUnit> with
        member __.Combine productTerm nextUnit =
            match (lastOp, nextOp) with
            | Lower, Raise when sameIndex ->
                // aᵢ a†ᵢ = 1 − a†ᵢ aᵢ
                [| identityTerm; swappedTermWithSign |]
            | Lower, Raise ->
                // aᵢ a†ⱼ = −a†ⱼ aᵢ (different indices)
                [| termWithSignFlip |]
            | _, _ ->
                // No commutation needed
                [| appendedTerm |]
```

When lowering operator `aᵢ` meets raising operator `a†ᵢ` at the same index, the algorithm generates two terms: an identity contribution and the swapped term with a sign flip.

### BosonicAlgebra (CCR)

The bosonic implementation uses commutation rather than anti-commutation:

```fsharp
type BosonicAlgebra () =
    interface ICombiningAlgebra<LadderOperatorUnit> with
        member __.Combine productTerm nextUnit =
            // bᵢ b†ⱼ = b†ⱼ bᵢ (i ≠ j)
            // bᵢ b†ᵢ = 1 + b†ᵢ bᵢ
```

For different indices there is no sign change. For equal indices, CCR generates an identity contribution plus the reordered product.

### The Normal Ordering Pipeline

```fsharp
type LadderOperatorSumExpr<'algebra when 'algebra :> ICombiningAlgebra<...>> =
    // 1. Take input expression
    // 2. For each product term:
    //    a. Repeatedly combine adjacent operators via algebra
    //    b. Collect all generated terms
    // 3. Sort indices within raise/lower groups
    // 4. Return normalized S<...>
```

## Type Safety: Preventing Invalid Constructions

The type system enforces several correctness properties:

### Compile-Time Operator Segregation

You cannot create a `P<'T>` containing both `LadderOperatorUnit` and `Pauli` values—the type parameter is fixed for the entire product.

### Algebra Semantics as an Explicit Choice

Within ladder-operator expressions, CAR vs CCR behavior is selected explicitly by the algebra type parameter on `LadderOperatorSumExpr<'algebra>`. This prevents silently applying fermionic rewrite rules to bosonic sectors (or vice versa).

### Index Consistency

The `IxOp<'index, 'op>` wrapper associates operators with mode indices:

```fsharp
type IxOp<'index, 'op> =
    { Index : 'index
      Op    : 'op }
```

This ensures indices travel with their operators through all transformations.

### Coefficient Hygiene

The `Reduce` method on each type sanitizes coefficients, converting NaN or infinity to zero. This prevents numerical issues from propagating:

```fsharp
member this.Reduce = { this with Coeff = this.Coeff.Reduce }
```

### Zero Propagation

Zero coefficients properly propagate through products and sums. A product containing any zero-coefficient term becomes the zero product:

```fsharp
member this.IsZero =
    (not this.Coeff.IsNonZero) ||
    (this.Units |> Seq.exists (fun item -> item.IsZero))
```

## Practical Patterns

### Building a Hamiltonian Term by Term

```fsharp
// One-body term: h₁₂ a†₁ a₂
let oneBody =
    let creation = C.Apply({ Index = 1u; Op = Raise })
    let annihilation = C.Apply({ Index = 2u; Op = Lower })
    S.Apply(Complex(h12, 0.), creation * annihilation)

// Two-body term: ½ ⟨12|34⟩ a†₁ a†₂ a₄ a₃
let twoBody =
    let ops = [| Raise; Raise; Lower; Lower |]
    let indices = [| 1u; 2u; 4u; 3u |]
    let ixOps = Array.map2 (fun i o -> { Index = i; Op = o }) indices ops
    S.Apply(Complex(0.5 * integral1234, 0.), P.Apply(ixOps))

// Combine
let hamiltonian = oneBody + twoBody
```

### Encoding and Combining

```fsharp
let encode term =
    term.ProductTerms.Value
    |> Array.map (fun p -> encodeProduct jordanWignerTerms p)
    |> PauliRegisterSequence

let pauliH = encode fermionicHamiltonian
```

The type parameter naturally changes from fermionic to Pauli as operators flow through the encoding boundary.

### Mixed Bosonic + Fermionic Registers

Mixed models are typically represented by partitioning mode indices into sectors and applying sector-specific normal ordering:

```fsharp
let fermionic = LadderOperatorSumExpr<FermionicAlgebra>.ConstructNormalOrdered exprF
let bosonic   = LadderOperatorSumExpr<BosonicAlgebra>.ConstructNormalOrdered exprB
```

Then encode fermionic terms with `jordanWignerTerms`/`bravyiKitaevTerms`/tree encodings, while keeping bosonic terms symbolic or passing them through a truncation layer. See [Mixed Registers](mixed-registers.html) for a full workflow.
