namespace Encodings

/// <summary>
/// Algebra interface for combining operator terms during normal ordering.
/// </summary>
/// <remarks>
/// When normal-ordering a product of fermionic operators, each swap of adjacent
/// operators may generate new terms via the canonical anti-commutation relations (CAR):
///
///   {aᵢ, a†ⱼ} = aᵢ a†ⱼ + a†ⱼ aᵢ = δᵢⱼ
///
/// The ICombiningAlgebra interface abstracts this: Combine takes two operators
/// and returns the terms generated by swapping them.
///
/// FermionicAlgebra implements the fermionic CAR. Other algebras (bosonic, anyonic)
/// could implement the same interface with different commutation relations.
/// </remarks>
[<AutoOpen>]
module CombiningAlgebra =
    open System.Numerics

    /// <summary>
    /// Interface for algebras that define how to combine (commute/anti-commute)
    /// operators when sorting into normal order.
    /// </summary>
    /// <typeparam name="'op">The type of operator units (e.g., LadderOperatorUnit).</typeparam>
    /// <remarks>
    /// <para>During normal ordering, operators must be rearranged so that all creation
    /// operators appear before all annihilation operators. Each swap may produce
    /// additional terms depending on the commutation relations of the algebra.</para>
    /// <para>The Combine method takes a partial product term and the next operator to append,
    /// returning all terms that result from the combination (including any terms generated
    /// by anti-commutation relations).</para>
    /// </remarks>
    type ICombiningAlgebra<'op when 'op : equality> =
        interface
            /// <summary>
            /// Combines a product term with the next operator unit.
            /// </summary>
            /// <param name="productTerm">The existing product of operators.</param>
            /// <param name="nextUnit">The next operator to combine with the product.</param>
            /// <returns>An array of product terms resulting from the combination,
            /// including any additional terms from commutation relations.</returns>
            abstract Combine : ((*productTerm : *)P<IxOp<uint32, 'op>>) -> ((*nextUnit : *)C<IxOp<uint32, 'op>>) -> P<IxOp<uint32, 'op>>[]
        end

    /// <summary>
    /// Implementation of ICombiningAlgebra for fermionic operators using
    /// canonical anti-commutation relations (CAR).
    /// </summary>
    /// <remarks>
    /// <para>Fermions obey the canonical anti-commutation relations:</para>
    /// <list type="bullet">
    /// <item><description>{a†ᵢ, aⱼ} = a†ᵢ aⱼ + aⱼ a†ᵢ = δᵢⱼ (Kronecker delta)</description></item>
    /// <item><description>{aᵢ, aⱼ} = aᵢ aⱼ + aⱼ aᵢ = 0</description></item>
    /// <item><description>{a†ᵢ, a†ⱼ} = a†ᵢ a†ⱼ + a†ⱼ a†ᵢ = 0</description></item>
    /// </list>
    /// <para>When swapping aᵢ past a†ⱼ during normal ordering:</para>
    /// <list type="bullet">
    /// <item><description>If i ≠ j: aᵢ a†ⱼ = -a†ⱼ aᵢ (sign flip only)</description></item>
    /// <item><description>If i = j: aᵢ a†ᵢ = 1 - a†ᵢ aᵢ (generates identity term)</description></item>
    /// </list>
    /// <para>This algebra is used by the normal ordering algorithm to properly account
    /// for all terms generated during operator rearrangement.</para>
    /// </remarks>
    type FermionicAlgebra () =
        class
            interface ICombiningAlgebra<LadderOperatorUnit> with
                /// <summary>
                /// Combines a product term with the next operator using fermionic anti-commutation.
                /// </summary>
                /// <param name="productTerm">The current product of operators.</param>
                /// <param name="nextUnit">The next operator to combine.</param>
                /// <returns>
                /// If the last operator in productTerm is Lower and nextUnit is Raise with the same index,
                /// returns two terms: the identity contribution and the swapped term.
                /// Otherwise returns a single term (possibly with sign flip if swapping Lower past Raise).
                /// </returns>
                member __.Combine productTerm nextUnit =
                    let nUnits = productTerm.Units.Length
                    let prefix =
                        if nUnits > 2 then
                            productTerm.Units.[0..(nUnits - 2)]
                        else
                            [| C<_>.Apply { IxOp.Op = Identity;  IxOp.Index = 0u } |]
                    let lastUnit = productTerm.Units.[nUnits - 1]
                    match (lastUnit.Item.Op, nextUnit.Item.Op) with
                    | Lower, Raise ->
                        if lastUnit.Item.Index <> nextUnit.Item.Index then
                            let term =
                                [|
                                    yield! prefix
                                    yield { nextUnit with Coeff = Complex.MinusOne }
                                    yield lastUnit
                                |] |> P<IxOp<uint32, LadderOperatorUnit>>.Apply
                            [| term.Reduce.Value |]
                        else
                            let leadingTerm =
                                [|
                                    yield! prefix
                                |] |> P<IxOp<uint32, LadderOperatorUnit>>.Apply
                            let trailingTerm =
                                [|
                                    yield! prefix
                                    yield { nextUnit with Coeff = Complex.MinusOne }
                                    yield lastUnit
                                |] |> P<IxOp<uint32, LadderOperatorUnit>>.Apply
                            [| leadingTerm.Reduce.Value; trailingTerm.Reduce.Value |]
                    | _, _ ->
                        let term =
                            [|
                                yield! productTerm.Units
                                yield nextUnit
                            |] |> P<IxOp<uint32, LadderOperatorUnit>>.Apply
                        [| term.Reduce.Value |]
        end
